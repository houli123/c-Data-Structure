[toc]

# 引言

## 结构

1. main为主函数，每个c程序必须又一个main()函数

2. {}为函数的范围

3. printf是库函数

4. 每个语句后面都要有一个分号;

5. //：注释一行

6. /* 多行语句 */：注释多行

   >快捷键：ctrl+/

7. 语句以return 0;结尾

8. 开头第一句话：#include <stdio.h>

9. **开头定义（宏定义）：define 名字 数值**

   > **终止宏定义：#undef 宏名**

10. 导入：include语句＋要导入的文件名

11. void：空类型

## 图表

1. 流程图

   |    符号    |    名称     |         含义         |
   | :--------: | :---------: | :------------------: |
   |    椭圆    |   起止符    |   算法的开始和结束   |
   | 平行四边形 | 输入/输出框 |    输入/输出操作     |
   |    矩形    |   处理框    | 对框内的内容进行处理 |
   |    菱形    |   判断框    | 对框内的条件进行判断 |
   |    箭头    |   流程线    |    表示流程的方向    |

2. N-S图

## 编译软件

- Dev-Cpp.6.7.5
- Visual Studio Code



# 顺序结构流程及应用

## 标识符与关键字

1. **标识符（变量名|函数名|各种名字）规则**：

   - **只能由字母、数字、下划线组成**（不能有特殊字符）
   - **以字母或下划线开头**（不能以数字开头）
   - 前8位字符有效，超过就舍去
   - 关键字不能用作标识符

2. 关键字

   有：auto、break、case、char、continue、default、do、else、float、for、if、int、void、while、switch等32个

## 常量

- 八进制**0开头**：0350

- > 0789表示的是八进制7和十进制89两个数

- 十六进制**0x或0X开头**：0x12

- 符号常量：#define 名字 数值

  > 调用时直接用名字

## 变量

### 数据类型的定义与赋值

```c
//常用数据类型
int i=10,*pi; 
float f=1.0;
char c='2';
long l=1;
double d=2;
struct student{}
union student{}
```

###  转义字符表(是反斜杠\不是斜杠/)

|  形式  |            含义             |
| :----: | :-------------------------: |
| **\n** |   换行，光标到下一行开头    |
| **\t** |           制表符            |
|   \b   |           退格符            |
| **\r** |   回车符，光标到本行开头    |
|   \f   |            换页             |
|  \\\   |              \              |
|  \\'   |              '              |
|  \000  |  1-3位八进制转化成一个字符  |
|  \xhh  | 1-2位十六进制转化为一个字符 |

```c
printf("\x30");
printf("\130");
```

### 各进制的转换

- 十转二：取2取余，倒着取
- 二转八：3位一组
- 二转十六：4位一组

### 常用ASCII码

|    符号     | 十进制  |
| :---------: | :-----: |
| **(space)** | **032** |
|    **0**    | **048** |
|    **A**    | **065** |
|      Z      |   090   |
|    **a**    | **097** |
|      z      |   122   |
|             |         |

> 同一个小写字母与大写字母差32位

### typedef的使用

`typedef`是C语言中的一个关键字，它用于为已存在的类型**定义一个新的名称**。使用`typedef`可以简化代码，提高可读性和可维护性。

```c
typedef int my_int;   // 将 int 类型定义为 my_int 
my_int i=10;

typedef float my_float;   // 将 float 类型定义为 my_float
my_float f=10.2;

typedef struct {  
    int x;  
    int y  
} Point;   // 将结构体类型定义为 Point
Point stu1,stu2;  //等价于struct Point stu1,stu2;

typedef int* my_int_ptr;   // 将 int 指针类型定义为 my_int_ptr
my_int_ptr *i=&10;

typedef int my_array[5];   // 将 int 数组类型定义为 my_array
my_array my={1,2}

typedef void (*my_func_ptr)(int);   // 将函数指针类型定义为 my_func_ptr
my_func_ptr(*i);
```

> `typedef`定义的类型仅仅是一个别名，它不会改变原有类型的本质。同时，`typedef`定义的变量没有内存空间，只是一个符号而已。

## 数据格式化输出与输入

### 格式化输出

```c
printf("文本等的，还可以%d|%s的",要代入%d的变量名);
printf("please input %d",int);
```

| 数据类型     | 格式符        | 描述                           |
| ------------ | ------------- | ------------------------------ |
| int型        | %d或%i        | 整数                           |
|              | **%md(%-md)** | **右对齐与左对齐**             |
|              | %ld           | long型数据                     |
|              | %o            | 以八进制输出整数               |
|              | **%x**        | **以十六进制输出整数**         |
| char型       | %c            | 单个字符                       |
|              | **%s**        | **字符串**                     |
| float,double | %f            | 小数输出实数，6位小数          |
|              | **%m.nf**     | **输出的数据占m列，小数占n列** |

```c
printf("%.2f",f);  //表示保留两位小数
```

### 输出单个字符

```c
putchar(ch);
```

### 格式化输入

```c
scanf("%f%d",&ifloat,&id);
```
> 输入单字符数据时，要回车才能结束，并且回车也会算进字符数据里。所以如果是循环的话，你输入一个数，但会循环两次
> 在scanf中使用‘\n’屏蔽回车符号：scanf("%d\n",&n);
> **在scanf格式符前加‘ ’空格屏蔽回车符号：scanf(" %d",&c);**
> **在接受字符后使用getchar()读取回车符：scanf("%d\n",&n);getchar()**
> 用fflush()清空输入流缓冲区的内容，相对的就能清掉回车符：scanf("%d\n",&n);fflush(stdin);        //需要头文件<stdlib.h>

| 数据类型 | 格式符    | 描述                                                         |
| -------- | --------- | ------------------------------------------------------------ |
| int型    | %d或%ld   | 带符号十进制整形或长整型                                     |
|          | %i        | 带符号的十六进制                                             |
|          | %o        | 无符号八进制输出整数                                         |
|          | %x        | 无符号十六进制输出整数                                       |
|          | %u        | 无符号十进制                                                 |
|          | %md(%-md) | 右对齐与左对齐                                               |
| 实数     | %f        | 实数                                                         |
| 字符     | %c        | 单个字符                                                     |
|          | **%s**    | **将字符串存在一个字符数组中，输入以空白字符结束，输出最后一个字符是'\c'，并且此时不需要加地址符&** |

### 单个字符输入

```c
ch=getchar();
getchar()
```

> 输入单字符数据时，要回车才能结束，并且回车也会算进字符数据里。所以如果是循环的话，你输入一个数，但会循环两次
> **在接受字符后使用getchar()读取回车符：scanf("%d\n",&n);getchar()**

### 字符串输入

```c
scanf("%S",cstring);//遇到空格回车结束输入
//或
gets(cstring);//遇到回车符结束输入,且在末尾自动加'\0'
```

### 字符串输出

```c
puts(cstring);
printf("%s",cstring);
```

> **其中**
>
> - `getchar()` 函数从标准输入（通常是键盘）读取一个字符，并将其返回。它不需要指定输入流，默认从标准输入读取。
> - `getc`：get character 的缩写，用于从指定的输入流中读取一个字符。函数则需要指定一个输入流（如文件指针），并从该输入流中读取一个字符。它可以用于从任意输入流中读取字符，不仅仅是标准输入。
> - `gets`：get string 的缩写，用于从标准输入（通常是键盘）读取一行字符串，并将其存储在指定的字符数组中。需要注意的是，由于 `gets` 函数无法限制输入的长度，容易导致缓冲区溢出，因此在现代的 C 语言编程中已经不推荐使用，建议使用 `fgets` 函数代替。
> - `putc`：put character 的缩写，用于将指定的字符写入到指定的输出流中。
> - `puts`：put string 的缩写，用于将指定的字符串写入到标准输出（通常是屏幕）中，并在末尾自动添加一个换行符。

## 运算符与表达式

### 基本算数运算符

- %必须都是整数
- 5/2=2

### 强制类型转换

```c
(类型名) <变量名>
(float) f;
```

### 逗号运算符

```c
表达式1,2,3,...n;
//其中整个表达式的值为n的值，其余的表达式只有赋值能生效，产生影响
```



# 选择结构流程

## 逻辑运算符

| 运算符 | 名称   | 优先级 |
| ------ | ------ | ------ |
| !      | 逻辑非 | 第一   |
| &&     | 逻辑与 | 第二   |
| \|\|   | 逻辑或 | 第三   |

> 先非后与后或

**注：在多个与中，第一个为假，则整个肯定为假，即短路，后面不运行**

**在多个或中，第一个为真，则整个肯定为真，则短路，后面不运行**



## 选择结构

### if-else if-else语句

```c
if(条件)
{
    语句1;
    语句2;
    ...
}

else if(条件)
{
    语句1;
    语句2;
    ...
}

else
{
    语句1;
    语句2;
    ...
}
```

> 注：其中如果语句中只有语句1，则可以省略{}，因为这种属于简单语句，比较明确，不会产生歧义
>
> 其中如果小if-else语句里面都只有一条语句，那么在大if中，这个小if就算作是一条一句，即是简单语句，可以省略{}

> else总是与它前面最接近它且没配对的if语句相配对

### 条件运算符

```c
表达式1 ? 表达式2 : 表达式3
//如果1为真则结果是变量2的值，否则是变量3的值
imax=i1>i2 ? i1 : i2;
```

> 多条条件表达式的结合性为“从右到左”

### switch语句

```c
switch(表达式)  //只能是int、char、枚举类型
{
    case 常量表达式1:
        语句1
        [break;]    
        //如果不break，那么该条件后的所有case都会执行
    case 常量表达式2:
        语句2
        [break;]
    ...
    case n
        
    [default:语句块n+1] //一个case都没有成立时执行
}

//可以case0:case1:case2:语句体   这样子使用，满足其中一个条件就执行
```



# 循环结构流程

## while语句

```c
while(表达式)
{
    语句体;
    [break;]
    [continue;]
}
```

## do-while语句

```c
do
{
    语句体;
}while(表达式);  //;不能省略
//至少执行语句体一次，如果为真则继续执行
```

> 所以while是先判断再执行循环，do-while是先循环在判断

> **while后的;不能省略**

## for循环

```c
for(初始表达式;循环条件;变量增值)
{
    循环语句
}
```

> for里的三个表达式都可以省略，但是中间的;不能省略



# 数组应用

> **因为数组本身就是一个地址，如果输出整个数组，那么结果就是数组的地址**
>
> **itest是itest[0]的地址，而itest+1是itest[1]的地址，以此类推**
>
> **所以*itest=itest[0],     \*(itest+1)=itest[1]**

## 一维数组

1. 定义

   ```c
   数据类型 数组名[数字]={初始值1,初始值2...};
   int itest[10]={1,2...};
   
   //如果设置了初始值，则数字个数可以省略，如：
   int itest[]={1,2,3};
   //静态数组（static）时，对数值型数组，如果不指定数据初始化，则其他数据自动赋值为'0'，对字符型数组，其他数据全为'\0；
   //动态数组(auto)，则初值不确定
   ```

   > 注：此时**数组名也要符合标识符的定义**

2. 引用

   ```c
   数值名[下标数字];
   itest[0-9];
   ```

   > 下标不存在越界行为

## 二维数组

```c
类型 数组名[行数][列数]={(),()};  //行数可以不写，但列数必须写,且花括号里可以不使用括号
int iscore[3][3] //三个同学，每个同学三科成绩
```

```c
数组名[行数][列数];
iscore[1][2];  //访问第二个同学的第三科成绩
```

## 字符数组与字符串数组

> 数组和字符串本身就是一个地址，如果输出整个数组，那么结果就是数组的地址，且形参的值改变，实参也会接着变
>
> **字符串本质上就是数组，所以也能用指针直接定义，不用指定数组大小**
>
> **itest是itest[0]的地址，而itest+1是itest[1]的地址，以此类推**
>
> **所以*itest=itest[0],     \*(itest+1)=itest[1]**
>
> - 同理：字符串中*s是第一个字符，+1往后一位，以此类推
> - *s+1与s+1是不同的。间接引用只是一个项，而s+1是整个字符串，但是+1后起始位置向右移了一位，因此是左边第二个到最后的字符串

- **字符数组与字符串数组的区别**

```c
/*字符数组赋初值*/
char p[6] = {'I'，'L'，'O'，'V'，'E'，'C'};
/*字符串赋初值*/
char *p="ILOVEC";  //等价于char p[] = "ILOVEC";  

printf("%s",p+1); //='LOVEC'，少了I
printf("%s",*p);  //='I'
printf("%s",*p+1);  //='L'
printf("%s",*(p+1);  //='L'
```

> **对于字符数组不能用printf的%s打印，若末尾加个'\0'，则是字符串，可以使用%s打印**
>
> **字符串数组因为字符串末尾有'\0'，所以多一位**
>
> **c语言没有字符串数据类型，只是结尾有'\0'的字符数组叫做字符串数组，字符串数组用来存储字符串**
>
> **若字符数组全部进行了初始化，则自动没有'\0'，所以不算字符数组**

- **字符串数组输入**

```c
char cstring[100];
scanf("%s",cstring);
//遇到空格回车结束输入，且因为不是单个字符而是字符串，所以不用地址符&

gets(cstring);//遇到回车符结束输入,且在末尾自动加'\0'
```

- **字符串输出**

```c
puts(cstring);
printf("%s",cstring);
```

- **常用字符串处理函数**

  > 这些函数都在头文件<string.h>里

  | 函数名 |                  功能                  |     格式      |              返回               |
  | :----: | :------------------------------------: | :-----------: | :-----------------------------: |
  | strlen |    测试字符串长度，不包括结束符'\0'    |   strlen(s)   |               有                |
  | strcpy |     将第二个参数复制到第一个参数里     | strcpy(s1,s2) |               无                |
  | strcat |     将第二个参数接到第一个参数后面     | strcat(s1,s2) |               无                |
  | strcmp | 逐个比较两字符串的字符，直到不同或'\0' | strcmp(s1,s2) | s1>s2则返回值＞0，<则<0，=0则=0 |

> **其中**
>
> - `strlen`：string length 的缩写，用于计算指定字符串的长度（不包括结尾的空字符 '\0'）。
> - `strcpy`：string copy 的缩写，用于将源字符串复制到目标字符串中。
> - `strcat`：string concatenate 的缩写，用于将源字符串连接到目标字符串的末尾。
> - `strcmp`：string compare 的缩写，用于比较两个字符串的大小。




# 函数

## 函数定义

> 函数要先声明、再定义、后调用

1. 声明

   ```c
   数据类型 函数名(形参的数据类型 形参, ...);
   void name(i1，char c1);  // i1默认为int型
   ```

   > **注：若函数定义的位置在调用的位置之前，则可以省去声明**
   >
   > **若不指定形参的数据类型，则默认为int型**

2. 定义

   ```c
   void name(int i1,，char c1)
   {
       ...
   }
   ```

   > **注：声明是以;结束，定义是以{}结束**

3. 调用

   ```c
   //无返回值,void
   name(i);
   //有返回值,int等
   x=name(i);
   ```

   > 函数的执行总是从main开始，遇到其他函数的调用再回到该处
   >
   > 形参的值不能传到实参里，且形参的声明周期只在该函数内


## 数组做函数参数

1. 数组元素做函数的实参，形参为单个字符

   ```c
   int isL(char ch1){}
   char chstring[10];
   isL(chstring[i]);
   ```

   > 注意区分：数组元素作参数相当于复制，所以不能传回实参，数组作为参数相当于传递地址，一个变另一个也变

2. **数组名做函数的实参与形参**

```c
//形参
float fn(float fscore[10]);
//实参
fn(fscore);
```

> **函数名作为函数的参数，必须在调用函数和被调用函数中分别定义数组，且数据类型一致**
>
> 如果要指定形参的大小，那么实参数组的大小必须大于性参数组
>
> **用数组名做函数的参数时，采用的是地址传递，所以此时函数内的数组改变，外面也会受影响**

## 函数的递归

```c
/*fn(5)=fn(4)+2
fn(4)=fn(3)+2
fn(3)=fn(2)+2
fn(2)=fn(1)+2
fn(1)=10*/
int iyear(int i){
	if(i>1)
		return iyear(i-1)+2;
	else
		return 10;
}
int main(){
	printf("the sum is %d",iyear(5));
    return 0;
}
```

```c
//n!
include <stdio.h> 
long fn(int i){
	if(i>1){
		return i*fn(i-1);
	}
	else return i;
}
int main(){
	int i;
	printf("请输入要求的阶乘n！");
	scanf("%d",&i);
	printf("%d!=%ld",i,fn(i));
    return 0;
}
```



> 递归特点：确定递归公式，确定递归函数的出口

## 变量的作用域和生存期

全局变量：即在任何函数外定义的变量，在任何函数中都可以使用

**动态、静态、寄存器存储变量与外部函数**

1. 动态存储变量

   ```c
   int i;
   //相当于(auto) int i
   ```

2. 静态存储变量

   ```c
   static int i;
   ```

   > **若在函数内使用static定义变量，则函数结束后的其他地方依旧可以使用该变量的值**
   >
   > 还有内部函数static int fn(int i);
   >
   > **若不赋值，则默认为0**

3. 寄存器

   ```c
   register long i;
   //用于存放超大值的循环变量，可以加快程序执行的顺序
   ```

4. 外部函数

   ```c
   extern int fn(int i);
   ```

   

# 位运算



# 结构体与共同体

## 结构体变量

- 结构体**类型**的定义

  ```c
  //struct 结构体类型名
  struct sname{
      int i;  //成员名，不能赋值
      char c;
      float f;
      ...
  };  //注意结尾的;
  ```

- 结构体**变量**的定义

  ```c
  struct 结构体类型名 结构体变量名;
  struct sname name={...};
  ```

- 结构体变量中成员的应用

  ```c
  //结构体变量名.成员名
  name.i
  ```

> 以上是间接定义法：第一步struct 类型名{成员名}，第二部struct 类型名 变量名，第三部变量名.成员名
>
> 结构体变量只能通过对成员进行引用
>
> 结构体的成员可以是数组和结构体变量
>
> 若两个结构体变量来自相同的结构体类型，则可以st1=st2

- 直接定义法

```c
struct sname{
    int i;
    char c;
}name1,name2;//定义结构体类型时同时定义结构体变量
```

```c
//结构体嵌套定义的案例
include <stdio.h>
struct date{
	int iyear,imonth,iday;
};
struct student{
	char cname[8];
	int ieng;
	struct date stBirth;
};
int main(){
	struct student stOrg={"Tom",30,1888,2,4},stBak;
	stBak=stOrg;
	printf("%s,%d,%d-%d-%d",stBak.cname,stBak.ieng,stBak.stBirth.iyear,stBak.stBirth.imonth,stBak.stBirth.iday);
}
```

## 结构体数组

```c
//定义结构体变量时
struct sname name[10];
//调用
name[1].cname;
//如
include <stdio.h>
struct sclass{
	char cname[10];
	int iscore;
}class[]={{"刘5",100},{"woshi",2}};
int main(){
	for(int i=0;i<2;i++){
		printf("%s,%d\n",class[i].cname,class[i].iscore);
	}
} 
```

## 结构体函数

> 结构体变量作为函数参数时，形参实参返回值都应该是结构体类型

```c
//struct 结构体类型名 函数名(结构体类型参数1...);
struct student fncalculate(struct student stStud[],int i);
//如果返回值是空
void fnculculate(struct student stStud[],int i);
```

```c
//结构体数组和结构体函数（形参与返回值都是结构体数组且结构体嵌套定义的案例）
include <stdio.h>
define N 2
struct id{
	int i1;
};
struct student{
	char cname[8];
	int ifinal;
	struct id id1;
};
struct student fnbest(struct student stB[],int i){   //只要函数形参是数组传递，那么都是地址传递
	for(int n=0;n<i-1;n++)
		printf("%s,%d,%d\n",stB[n].cname,stB[n].ifinal,stB[n].id1.i1);
	return stB[i-1];
}

int main(){
	struct student stA[]={{"aa",23,1},{"bb",22,2}},stC;
	stC=fnbest(stA,N);
	printf("%s,%d,%d\n",stC.cname,stC.ifinal,stC.id1.i1);
	return 0;
}
```

## 共同体

定义同结构体一样，但是不能用作函数参数，返回值与初始化赋值，该知识点不重要

```c
union uname{
  int i1;  
};
union uname name;
name.i1;
```



# 指针

> 一个变量在内存中的地址称为该变量的指针，即&x
>
> 指针是常量

## 指向变量的指针（变量）

### 定义

```c
类型 *指针变量名=&变量名;  //定义时指针带的*是声明这个变量是指针变量，并不是用间接引用
int *i1=&i2;
或
类型* 指针变量名=&变量名;
int* i1=&i2;
```

> 类型* 指针名 == 类型 *指针名
>
> struct* stu==struct *stu

### 指针运算

> 程序可以利用指针间接引用变量，此时为变量的值

```c
*指针变量名;
*i1;

char *p="ILOVEC";  //等价于char p[] = "ILOVEC";  
printf("%s",p+1); //='LOVEC'，少了I
printf("%s",*p);  //='I'
printf("%s",*p+1);  //='L'
printf("%s",*(p+1);  //='L'
```

> *是间接引用运算符，优先级与++相同，它可以访问指针变量所指向的变量的值
>
> **其中：pix=&ix,*pix=ix**
>
> ix和*pix是变量的值，&ix和pix是变量的地址
>
> **scanf时，如果是指针变量，那么不用带&就是地址**
>
> **指针变量只能指向同类型的变量**

### 指针变量作为函数的参数

```c
//函数形参定义
void fn(int *i1,int* i2)
{
    //在函数内部，通过指针间接访问变量来修改变量的值
    *i1=*i2;  
}    
//函数调用传递实参
fn(&i1,&i2);
```

> **注：如果是在函数内部改变形参的地址，而不是形参的值时，实参的值不会相应的变化**
>
> 指针变量（地址）作为函数的实参时，将变量的地址传递到形参中，是一种地址传递方式。**函数中改变指针形参地址时，不能够改变指针的实参值，但是可以改变该指针变量所指向变量的值，此时能够改变实参的值，例如：**

```c
//改变地址不会影响实参案例
void fn(int *a,int *b){
	int num;  //num作为指针的值
    num=*a;*a=*b;*b=num;  //改变指针指向变量的值，形变实变
}
int main(){
	int a=1,b=2;
    printf("改变前：%d,%d\n",a,b);
	fn(&a,&b);
    printf("改变后：%d,%d",a,b);
}结果1,2 \n 2,1
    
//改变值才会影响实参案例
void fn(int *a,int *b){
	int *num;  //num作为指针的地址
	num=a;a=b;b=num;  //改变指针的地址，形变实不变
}
int main(){
	int a=1,b=2;
	printf("改变前：%d,%d\n",a,b);
	fn(&a,&b);
	printf("改变后：%d,%d",a,b);
}结果1,2 \n 1,2
```

### 引用形参与指针形参的区别

- 引用运算符&

引用运算符（&）的主要用途是获取变量的内存地址。**它运用在函数中时，函数内的值变动，实参也会变。**

```c
void increment(int *a) {  
    (*a)++;  
}  
  
void increment(int &a) {  
    a++;  
}
```

> 引用形参和指针形参实际上是相同的概念，只是描述方式不同，引用形参更节省空间。

## 指向数组的指针（变量）

```c
//指针指向数组的一个元素
int idate[3],*pint=&idate[0];
//指针直接指向整个数组，此时pint=idate[0]
int idate[3],*pint=idate;//此时fn(pint)=fn(idate)

//用指针定义字符串，此时*c的值为A，＋1往后一位
char *c="ABCD";
//等价于
char c[]="ABCD";
    
-------------------------------------------------------
char *p="ILOVEC";  //等价于char p[] = "ILOVEC";  
printf("%s",p+1);  //='LOVEC'，少了I
printf("%s",*p);   //='I'
printf("%s",*p+1);  //='L'
printf("%s",*(p+1);  //='L'
```

> **因为数组本身就是一个地址，如果输出整个数组，那么结果就是数组的地址，且形参的值改变，实参也会接着变**
>
> **字符串同理，字符串本质上也是个数组**
>
> **itest是itest[0]的地址，而itest+1是itest[1]的地址，以此类推**
>
> **所以*itest=itest[0],     \*(itest+1)=itest[1]**

```c
//所以有数组元素的四种访问方式  
//1.数组直接引用法
idate[i];
//2.数组间接引用法
*(idate+i);  //一整个语句指idate[i]，内部是idate[i]的地址
//3.指针下标法
pint[i];  //因为现在指针pint就是idate数组的地址，相当于数组本身，所以可以按照数组引用成员的方式，也可以按照指针自己间接引用的方式
//4.指针间接引用法
*(pint+i)
```

## 指向结构体的指针（变量 ）

### 定义

```c
struct 结构体类型名 *指针变量名;
struct student *pstu;
```

> 结构体变量的首地址就是该结构体变量的指针。用&即可获得结构体变量的指针。
>
> **就是说结构体指针变量默认指向结构体变量的首地址，而如果要指向指定的结构体变量地址，那需要特殊说明。**
>
> 指针变量指向结构体变量的方法：

```c
指针变量名=&结构体变量名;
pstu=&stu;  //只有定义指针和间接引用时才有*
```

### 结构体变量成员访问的方式

``` c
结构体变量名.成员名;

//(*结构体指针变量名).成员名;
(*pstu).name
    
//结构体指针变量名->成员名;
pstu->name
```

**用指针访问结构体变量成员基本上都是用pstu->name**

> **必须要先用*pstu=&stu指向后才能使用后两种办法**
>
> **注意考虑优先级的问题，()最高，然后.和->最后才是指针符***
>
> **若成员不是字符串的话，用scanf时还是要加地址符&，因为是非字符串的字符或数**

### 用指针来循环访问结构体数组的方式

```c
for(;pstu<=stu;pstu++){
    printf("%s=%d",pstu->cname,(*pstu).icount)
}
    
for(i=0;i<4;i++){
    printf("%s=%d",(pstu+i)->cname,(*(pstu+i)).icount)
}
```

### 指向结构体的指针（变量）作为函数参数

> 地址传递

```c
//实参传递结构体数组变量名，形参传递结构体指针变量（定义一个结构体指针变量）
struct student{
}stu[10];

void fn(struct student *pstu){
};

main(){
    fn(stu)
}
```

> 则函数内部调用结构体指针时应使用如下方法：
>
> **(*pstu).name**       ---等价于student.name
> **pstu->name**

## 线性链表

> 线性链表就是数据的逻辑结构是**线性结构**且数据的存储结构是**链式存储结构**的一种**动态分派存储**空间的数据结构

### 链表的结构

一个存储单元叫一个结点，每个结点由两个域组成：

- 数据域
- 指针域--指向后继结点的指针

头指针指向链表的首结点，尾指针指向NULL，作为链表的结束标志

### 链表的分类：

**总体上分为动态链表和静态链表：**

- 静态链表的大小是固定的，不能动态地增加或减少。
- 动态链表使用动态内存分配来创建节点。**动态链表使用系统提供的标准函数malloc和free来实现结点的动态分配和回收。动态链表可以是单链表、双链表、单循环链表、双循环链表等。**

链表分为：

- 单向链表

- **双向链表**--既有前驱结点又有后驱结点

  > 如何区分单向还是双向链表？
  >
  > 只用看定义了是只有一个next指针还是不仅有next指针还有prior前驱指针

  ```c
  struct LinkNode{
      int data;
      struct LinkNode *next,*prior;//定义指向下一位和上一位的指针
  };
  ```

- 单向循环链表--原来的尾指针指向头指针

- 双向循环链表--原来的尾指针指向头指针且头指针指向尾

### 动态链表的准备工作：malloc和free

- **malloc()函数**--malloc是memory allocation的缩写，译为内容分配或动态分配。该函数的返回值是一个无类型指针void*，若想输出出来则可以printf("%p")的方式输出该函数返回值的指针。malloc()函数在头文件<stdint.h>或\<malloc>中

  ```c
  #include <malloc.h>
  void *malloc(unsigned size);
  //动态分配一块参数大小的连续的存储空间，并返回空间的首地址
  -------
  int *ptr, num = 5;    
  ptr = (int*)malloc(num * sizeof(num)); // 分配内存空间，（int*)是强制返回指针整形，num * sizeof(int)来计算所需字节数。sizeof(int)返回类型的字节数。
  //该语句使ptr指针指向分配出来的内存空间的首地址
  ```

- **calloc()函数**

  > --complex allocate
  >
  > 作用是在内存开辟num个大小为size字节的连续空间，即num*size字节的内存空间，并将此存储空间的首地址作为函数值返回

  ```c
  #include <malloc.h>
  #include <stdlib.h>
  void *calloc(unsigned num,type size);
  ---
  int *ptr, num = 5;    
  ptr = (int*)calloc(num,sizeof(num)); 
  ```

  > malloc和calloc的区别主要有：
  >
  > 1. 形式不同：
  >
  >    void *malloc(size_typesize);
  >
  >    void *calloc(size_typenum,size_typenumberOfElemnt)。
  >    
  >    \---
  >    
  >    ptr = (int*)malloc(num * sizeof(num));      //一个参数
  >    
  >    ptr = (int*)calloc(num,sizeof(num));          //两个参数
  >    
  > 2. **calloc在动态分配完内存后，自动初始化该内存空间为零，而malloc不初始化，里边数据是随机的垃圾数据。**
  >

- **free()函数**

  ```c
  #include <malloc.h>
  void free(void *pt);
  //释放指针变量pt指向的空间块，交还给系统
  -----
  free(ptr);
  ```

- **sizeof运算符**

  计算数据类型的字节数，返回字节数的个数，类型为整形

  ```c
  sizeof (数据类型/变量名)
  printf("%d",sizeof(int));
  ```

  > 各个类型占用的字节数
  >
  > char:1
  >
  > int:4
  >
  > char[n]:n
  >
  > float:4
  >
  > long:4

- **typedef关键字**

  用于为现有的数据类型定义一个新的名字，**即数据类型重命名**

  ```c
  typedef <数据类型> <别名>;
  typedef int zhengshu;
  typedef int *zhengshuzhizhen;
  zhengshu x=1;   //等价于int x=1;
  zhengshuzhizhen p;  //等价于int *p;
  ------------------------------------------
  typedef struct {  
      int x;  
      int y;  
  } Point;  //定义了一个名为point的结构体变量，之后就可以用point来定义结构体变量了
  point p={1,2}
  ```

  

### 链表的创建

一个个地开辟结点和输入结点数据，并建立先后相连关系

- 静态链表

  > 静态链表就是一种用数组的方式模拟链表
  >
  > 其中静态链表中每个结点都有下标和每个结点对应的下一个结点的下标
  >
  > **静态链表适用于需要分配较大空间，插入和删除都不需要移动元素的线性表**
  >
  > | 下标 | 数据 | 指向（下标） |
  > | ---- | ---- | ------------ |
  > | 0    |      | 2            |
  > | 1    | b    | 5            |
  > | 2    | a    | 1            |
  > | 3    | d    | -1           |
  > | 4    |      |              |
  > | 5    | c    | 3            |
  >
  > 从下标0开始，一直到指向为-1的结点
  >
  > a->b->c->d
  >
  > 
  >
  > **注意区分：静态链表的指针表示的是下一个元素在数组中的位置，即下标。**
  >
  > **而动态链表的指针表示的是下一个元素的地址**
  >
  > 
  >
  > **插入一个数据域为e的结点：**
  >
  > 只需使一个空的结点变成：
  >
  > | 3    | d    | 4    |
  > | ---- | ---- | ---- |
  > | 4    | e    | -1   |
  >
  > a->b->c->d->e

```c
include <stdio.h>
struct LinkNode{
    int data;
    struct LinkNode *next;  //定义指向下一位的指针
};

void test(){
	struct LinkNode node1={10,NULL};  //定义各结点的数据域
	struct LinkNode node2={20,NULL};
	struct LinkNode node3={30,NULL};
	
	node1.next=&node2;  //定义各节点的指针域
	node2.next=&node3;
	
	//如何遍历链表？
	//先定义一个辅助指针变量（也可以理解为当前的指针域，先拿到头指针）
	struct LinkNode *pCurrent=&node1; //拿到链表的第一个结点相当于拿到整个链表
	while(pCurrent != NULL){
		printf("%d ",pCurrent->data);
		//指针移到下一个元素的首地址
		pCurrent=pCurrent->next;
	}
}

int main(){
	test();
}
```

- 动态链表+链表的遍历

  > 链表的遍历就是把每个结点都访问一次
  
  ```c
  #include <stdio.h>
  #include <malloc.h>
  struct node //结点
  {
  	int iorder;char cname[15],ctel[15];
  	struct node *pNext;  //指向下一位的指针域
  }*phead;
  
  int main(){
  	struct node *pTr;
  	pTr=(struct node *)malloc(sizeof(struct node));
  	//(struct node *)是强制返回结构体类型为node的指针变量,所以相当于指针变量指向结构体变量
  	//sizeof(struct node)来计算结构体node所需的字节数，并用malloc函数开辟空间
  	phead=pTr;  //使phead指向首结点
  	scanf("%d%s%s",&pTr->iorder,pTr->cname,pTr->ctel);
  	pTr->pNext=NULL;  //接收数据完毕，指针域赋值为空
  	
  	//把当前指针域设回头指针，从头开始遍历
  	pTr=phead;
  	printf("%d,%s,%s",pTr->iorder,pTr->cname,pTr->ctel);
  }
  ```



# 文件

## 文件的概念

### 文件

“文件”是指存储在外部介质（如磁盘）上数据的集合，操作系统是以文件为单位对数据进行管理的，c语言中有两种文件：

1. **程序文件**，包括"**.c**"源程序文件，'**.obj**'目标文件，'**.exe**'可执行文件，这种文件的内容是程序代码

2. **数据文件**，文件的内容是**供应程序运行时读写的数据**，如在程序运行过程中输出到磁盘（或其他外部设备）的数据，或在程序运行过程中供读入内存的数据

   > 输入输出称为**输入输出流**。流表示信息从源端到目的端的流动。c语言把文件看做是一个字符（字节）排序，即由一个一个字符（字节）的数据顺序组成。**一个输入输出流就是一个字节或二进制流**。c语言的数据文件由一连串的字符（字节）组成，对文件的存取是以字符（字节）为单位的。输入输出数据流的开始和节数仅受程序控制而不受物理符号（如回车换行符）控制，这种文件称为**流式文件**

   **数据文件分为ASCII文件和二进制文件**

   - **ASCII文件又称文本文件，每一个字节放一个字符的ASCII代码**，**用于字符型数据**。如10000占5个字节
   - **二进制文件就是把内存中的数据原样输出到磁盘上**。如10000占4个字节

### 文件名

包括三个部分：文件路径、文件名主干和文件后缀

D:\test\temp      \     file                       .dat

> ↑文件路径        ↑文件名主干         ↑文件后缀

### 文件缓冲区

缓存文件系统指系统自动地在内存区为程序中每一个正在使用的文件开辟一个文件缓冲区，**装满后才统一送到磁盘中。**

> 每一个文件在内存中只有一个缓冲区

## 文本（数据）文件的读写

> **读写文件的步骤：**
>
> **1.打开文件指针 FILE**
>
> **2.打开文件 fopen**
>
> **3.读写文件 **
>
> **4.关闭文件 fclose**

1. 定义文件指针

   ```c
   FILE *fp;
   FILE *fp=fopen("1.txt","rw");
   ```

2. 打开文件

   ```c
   fp=fopen(filename,mode);
   ---
   fp=fopen("1.txt","rw");
   if(fp==NULL){
   	printf("打开失败");
   	exit(0);
   ```

   > **成功时返回非空指针，失败返回NULL或0**
   >
   > 以mode的操作方式打开文件，**若打开失败则返回NULL**，NULL在stdio.h中定义为0
   >
   > 若想存入**指定目录（注意是两个反斜杠\\）**则可以像这样：fopen("D:\\\1.txt","w")
   >
   > **exit()函数是关闭所有文件，终止正在执行的程序。需要使用include <stdlib.h>库**
   >
   > - **`0`**：表示程序执行**成功**
   >
   > - `1`：表示程序执行**出错或异常。**
   > - `2`：表示程序用**法不正确或参数错误。**

   文件操作方式：

   | 文件类型                         | 操作方式          | 处理方式   | 文件不存在时   | 文件存在时         |
   | -------------------------------- | ----------------- | ---------- | -------------- | ------------------ |
   | 文本文件                         | r                 | 只读       | 出错           | 正常               |
   |                                  | w                 | 只写       | **建立新文件** | 原内容丢失         |
   |                                  | a                 | 添加       | **建立新文件** | 在原有内容末尾添加 |
   |                                  | **上面三个后加+** | 都表示读写 |                |                    |
   | 二进制文件（**字母后+号前加b**） | rb                | 只读       | 出错           | 正常               |
   |                                  | wb                | 只写       | **建立新文件** | 原内容丢失         |
   |                                  | ab                | 添加       | **建立新文件** | 在原有内容末尾添加 |
   |                                  | 上面三个后加+     | 都表示读写 |                |                    |

3. 读写文件函数

   | 函数名    | 调用                                        | 功能                                                     | 返回值                                                       |
   | --------- | ------------------------------------------- | -------------------------------------------------------- | ------------------------------------------------------------ |
   | fopen     | fopen(".dat",'rwab+')                       | 打开数据文件                                             | **成功返回起始地址**，**失败返回NULL（0）**                  |
   | fclose    | fclose(fp)                                  | 关闭文件                                                 | **成功0，失败EOF（-1）**                                     |
   | fgetc     | fgetc(fp)                                   | 从fp中**读**一个字符                                     | 返回所读字符，若**不成功，返回EOF（-1）**                    |
   | fputc     | fputc(ch,fp)                                | 将ch单个字符**写**入fp文件中                             | 返回该字符，**否则EOF（-1）**                                |
   | **fgets** | fgets(**str,n,fp**)                         | 从fp中**读**长度为(n-1)的字符串存入起始地址未str的空间中 | 返回str地址，**否则NULL（0）**                               |
   | **fputs** | fputs(**str,fp**)                           | 将str**写**入fp中                                        | **成功0，否则非0**                                           |
   | feof      | feof(fp)                                    | 测试fp所指的文件是否为文件结束                           | **文件未结束0，文件结束返回非0**                             |
   | fprintf   | fprintf(fp,"%d等格式化字符串",&i等输出列表) | 将i,f的内容**按格式写**入到fp中                          | **返回成功打印的字符数**（不包括最后的空字符 '\0'），**否则返回负值。** |
   | fscanf    | fscanf(fp,"%d等格式化字符串",&i等输出列表)  | 将fp里的数据按**格式读**取到i和f中                       | `fscanf`函数返回成功读取且赋值的字段数量，如果**读取失败或到达文件末尾，则返回EOF。** |

   > EOF 是 End Of File 的缩写，表示文件结束符，**EOF其值为-1**。
   >
   > 说是有返回值但是其实**返回值可以省略**
   >
   > 用`fgets`时，可以将n指定为str字符串的大小，这样不管多大都可以全部输出出来

4. 关闭文件

   ```c
   [c=]fclose(fp);
   ```

   > **成功返回NULL即0，否则返回非0**，表示关闭失败
   >
   > **c可以省略**

5. 其他知识

   - main()函数

     主函数的原型：

     ```c
     int main(int argc, char *args[]...);
     ```

     > `argc` 是 "argument count" 的缩写，意思是参数计数
     >
     > `args`是“arguments”的缩写，意思是参数（形参实参都可）
     >
     > parameter表示的是形参
     >
     > 其中，**`argc` 表示传递给主函数的参数个数**，而 **`args` 是一个指向char数组的指针**，用于存储传递给主函数的参数值。
     >
     > 命令行参数可以有多个
     >
     > **args[0]存放正在执行文件的文件名，args[1]存放第1个参数**，args[2]存放第2个参数...
     >
     > **实际传实参时只用指定args的参数，即使是参数的第一项也是赋值给args[1]的。但是该形参必须写上去**

   - 文件的存储形式

     1. 文本文件：也叫ASCII文件，文本文件是以字符编码的方式进行保存的。文本文件每个字节存放一个字符的ASCII码，但它占用更多的空间，且输出数据时要花费转换时间
     2. 二进制文件：二进制文件是以二进制的方式进行保存的，即文件中存储的是二进制数据。将内存中的数据按其原样存放在磁盘文件中，节省了磁盘空间和转换时间，但一个字节不对应一个字符

   - 文件的处理方式

     1. 缓冲文件系统是指使用标准I/O库函数（如fopen、fread、fwrite等）进行文件操作时，数据在内存和文件之间传输时会经过一个缓冲区。在读取文件时，**数据先从文件读入缓冲区，然后再从缓冲区读入程序**；在写入文件时，**数据先从程序写入缓冲区，然后再从缓冲区写入文件**。这种方式可以提高文件操作的效率，因为内存操作比磁盘操作更快。
     2. 非缓冲文件系统则是指直接使用系统调用（如open、read、write等）进行文件操作时，数据直接从程序传输到文件或从文件传输到程序，没有经过缓冲区。这种方式相对于缓冲文件系统来说更加底层和直接，但效率可能较低。

     需要注意的是，在实际编程中，一般推荐使用标准I/O库函数进行文件操作，因为它们更加高级、易于使用，并且可以提供更好的跨平台兼容性。只有在需要更底层和直接的控制时，才考虑使用系统调用进行文件操作。

## 二进制文件的读写

**fread函数从文件读一个数据库，fwrite向文件写一个数据块，在读写时是以二进制形式进行的**

| 函数名 | 调用                         | 功能                                                | 返回值        |
| ------ | ---------------------------- | --------------------------------------------------- | ------------- |
| fread  | fread(butter,size,count,fp)  | **从fp文件读入count个size字节的数据到butter数组中** | **count的值** |
| fwrite | fwrite(butter,size,count,fp) | **从butter数组中写入count个size字节的数据到fp中**   | **count的值** |

> 说明
>
> **buffer：一个地址**
>
> **size：一个数据项的字节数**
>
> **count：多少个数据项**

## 文件的随机读写

我们使用fopen打开一个文件可以得到一个文件指针，这个文件指针也会被用于读写文件的时候。我们在读取一个文件的时候，文件指针指向下一个我们要读取的字符（一开始指向第一个字符），每当我们调用一次读取函数时，如 fgetc/fgets，这个文件指针就会向后移动一个或者多个单位。

文件的随机读写，其实就是我们可以指定这个文件指针指向的位置，即指向第几个字符，然后从这个字符开始读写



# 附录

| 函数                         | 说明                                                         | 返回值                              |
| ---------------------------- | ------------------------------------------------------------ | ----------------------------------- |
| **rewind(fp)**               | 使文件位置标记到开头                                         | 无                                  |
| **ftell(fp)**                | 返回当前文件指针相对于起始位置的偏移量，这里说的起始位置，默认指的是文件开始的位置 | 成功返回一个偏移量；**失败返回-1L** |
| **fseek(fp,offset，origin)** | 给定**origin（0开头，1当前位置，2末尾）**和**offset（大于0右移，小于0左移）**，移动文件指针到指定位置 | **成功0，失败非0**                  |

> | origin（也可以用） | 等价于 |
> | ------------------ | ------ |
> | SEEK_CUR           | 1      |
> | SEEK_SET           | 0      |
> | SEEK_END           | 2      |
>
> 

## 优先级：

| 优先级 | 运算符 |    名称或含义    |  结合方向  |
| :----: | :----: | :--------------: | :--------: |
|   1    |   []   |     数组下标     |   左到右   |
|        |   ()   |      圆括号      |            |
|        |   .    | 成员选择（对象） |            |
|        |   ->   | 成员选择（指针） |            |
|   2    | **-**  |  **负号运算符**  | **右到左** |
|        | (类型) |   强制类型转换   |            |
|        |   ++   |  **自增**运算符  | 单目运算符 |
|        |   --   |  **自减**运算符  | 单目运算符 |
|        |   *    |    取值运算符    | 单目运算符 |
|        |   &    |   取地址运算符   | 单目运算符 |
|        |   !    |   逻辑非运算符   | 单目运算符 |
|        |   ~    |  按位取反运算符  | 单目运算符 |
|        | sizeof |    长度运算符    |            |
|   3    |   /    |        除        |   左到右   |
|        |   *    |        乘        | 双目运算符 |
|        |   %    |   余数（取模）   | 双目运算符 |
| **4**  | **+**  |      **加**      | **左到右** |
|        | **-**  |      **减**      | 双目运算符 |
|   5    |   <<   |       左移       |   左到右   |
|        |   >>   |       右移       | 双目运算符 |
| **6**  |   >    |       大于       |   左到右   |
|        |   >=   |     大于等于     | 双目运算符 |
|        |   <    |       小于       | 双目运算符 |
|        |   <=   |     小于等于     | 双目运算符 |
| **7**  |   ==   |       等于       |   左到右   |
|        |   !=   |      不等于      | 双目运算符 |
| **8**  | **&**  |    按位**与**    |   左到右   |
| **9**  | **^**  |   按位**异或**   |   左到右   |
| **10** | **\|** |    按位**或**    |   左到右   |
|   11   |   &&   |      逻辑与      |   左到右   |
|   12   |  \|\|  |      逻辑或      |   左到右   |
|   13   |   ?:   |    条件运算符    | **右到左** |
|   14   |   =    |    赋值运算符    | **右到左** |
|        |   /=   |     除后赋值     |            |
|        |   *=   |     乘后赋值     |            |
|        |   %=   |    取模后赋值    |            |
|        |   +=   |     加后赋值     |            |
|        |   -=   |     减后赋值     |            |
|        |  <<=   |    左移后赋值    |            |
|        |  >>=   |    右移后赋值    |            |
|        |   &=   |   按位与后赋值   |            |
|        |   ^=   |  按位异或后赋值  |            |
|        |  \|=   |   按位或后赋值   |            |
|   15   |   ,    |    逗号运算符    |   左到右   |

> 非大于与大于或
>
> **->优先级大于++--**
>
> **口诀：！》 算术运算符 》 关系运算符 》 && 》 || 》 赋值运算符**

## ASCII码表：

|  二进制  | 十进制 | 十六进制 |                  字符/缩写                   |                解释                |
| :------: | :----: | :------: | :------------------------------------------: | :--------------------------------: |
| 00000000 |   0    |    00    |                  NUL (NULL)                  |               空字符               |
| 00000001 |   1    |    01    |           SOH (Start Of Headling)            |              标题开始              |
| 00000010 |   2    |    02    |             STX (Start Of Text)              |              正文开始              |
| 00000011 |   3    |    03    |              ETX (End Of Text)               |              正文结束              |
| 00000100 |   4    |    04    |          EOT (End Of Transmission)           |              传输结束              |
| 00000101 |   5    |    05    |                ENQ (Enquiry)                 |                请求                |
| 00000110 |   6    |    06    |              ACK (Acknowledge)               |         回应/响应/收到通知         |
| 00000111 |   7    |    07    |                  BEL (Bell)                  |                响铃                |
| 00001000 |   8    |    08    |                BS (Backspace)                |                退格                |
| 00001001 |   9    |    09    |             HT (Horizontal Tab)              |             水平制表符             |
| 00001010 |   10   |    0A    |          LF/NL(Line Feed/New Line)           |               换行键               |
| 00001011 |   11   |    0B    |              VT (Vertical Tab)               |             垂直制表符             |
| 00001100 |   12   |    0C    |          FF/NP (Form Feed/New Page)          |               换页键               |
| 00001101 |   13   |    0D    |             CR (Carriage Return)             |               回车键               |
| 00001110 |   14   |    0E    |                SO (Shift Out)                |              不用切换              |
| 00001111 |   15   |    0F    |                SI (Shift In)                 |              启用切换              |
| 00010000 |   16   |    10    |            DLE (Data Link Escape)            |            数据链路转义            |
| 00010001 |   17   |    11    |  DC1/XON (Device Control 1/Transmission On)  |         设备控制1/传输开始         |
| 00010010 |   18   |    12    |            DC2 (Device Control 2)            |             设备控制2              |
| 00010011 |   19   |    13    | DC3/XOFF (Device Control 3/Transmission Off) |         设备控制3/传输中断         |
| 00010100 |   20   |    14    |            DC4 (Device Control 4)            |             设备控制4              |
| 00010101 |   21   |    15    |          NAK (Negative Acknowledge)          |     无响应/非正常响应/拒绝接收     |
| 00010110 |   22   |    16    |            SYN (Synchronous Idle)            |              同步空闲              |
| 00010111 |   23   |    17    |       ETB (End of Transmission Block)        |       传输块结束/块传输终止        |
| 00011000 |   24   |    18    |                 CAN (Cancel)                 |                取消                |
| 00011001 |   25   |    19    |              EM (End of Medium)              | 已到介质末端/介质存储已满/介质中断 |
| 00011010 |   26   |    1A    |               SUB (Substitute)               |             替补/替换              |
| 00011011 |   27   |    1B    |                 ESC (Escape)                 |             逃离/取消              |
| 00011100 |   28   |    1C    |             FS (File Separator)              |             文件分割符             |
| 00011101 |   29   |    1D    |             GS (Group Separator)             |          组分隔符/分组符           |
| 00011110 |   30   |    1E    |            RS (Record Separator)             |             记录分离符             |
| 00011111 |   31   |    1F    |             US (Unit Separator)              |             单元分隔符             |
| 00100000 |   32   |    20    |                   (Space)                    |                空格                |
| 00100001 |   33   |    21    |                      !                       |                                    |
| 00100010 |   34   |    22    |                      "                       |                                    |
| 00100011 |   35   |    23    |                      #                       |                                    |
| 00100100 |   36   |    24    |                      $                       |                                    |
| 00100101 |   37   |    25    |                      %                       |                                    |
| 00100110 |   38   |    26    |                      &                       |                                    |
| 00100111 |   39   |    27    |                      '                       |                                    |
| 00101000 |   40   |    28    |                      (                       |                                    |
| 00101001 |   41   |    29    |                      )                       |                                    |
| 00101010 |   42   |    2A    |                      *                       |                                    |
| 00101011 |   43   |    2B    |                      +                       |                                    |
| 00101100 |   44   |    2C    |                      ,                       |                                    |
| 00101101 |   45   |    2D    |                      -                       |                                    |
| 00101110 |   46   |    2E    |                      .                       |                                    |
| 00101111 |   47   |    2F    |                      /                       |                                    |
| 00110000 |   48   |    30    |                      0                       |                                    |
| 00110001 |   49   |    31    |                      1                       |                                    |
| 00110010 |   50   |    32    |                      2                       |                                    |
| 00110011 |   51   |    33    |                      3                       |                                    |
| 00110100 |   52   |    34    |                      4                       |                                    |
| 00110101 |   53   |    35    |                      5                       |                                    |
| 00110110 |   54   |    36    |                      6                       |                                    |
| 00110111 |   55   |    37    |                      7                       |                                    |
| 00111000 |   56   |    38    |                      8                       |                                    |
| 00111001 |   57   |    39    |                      9                       |                                    |
| 00111010 |   58   |    3A    |                      :                       |                                    |
| 00111011 |   59   |    3B    |                      ;                       |                                    |
| 00111100 |   60   |    3C    |                      <                       |                                    |
| 00111101 |   61   |    3D    |                      =                       |                                    |
| 00111110 |   62   |    3E    |                      >                       |                                    |
| 00111111 |   63   |    3F    |                      ?                       |                                    |
| 01000000 |   64   |    40    |                      @                       |                                    |
| 01000001 |   65   |    41    |                      A                       |                                    |
| 01000010 |   66   |    42    |                      B                       |                                    |
| 01000011 |   67   |    43    |                      C                       |                                    |
| 01000100 |   68   |    44    |                      D                       |                                    |
| 01000101 |   69   |    45    |                      E                       |                                    |
| 01000110 |   70   |    46    |                      F                       |                                    |
| 01000111 |   71   |    47    |                      G                       |                                    |
| 01001000 |   72   |    48    |                      H                       |                                    |
| 01001001 |   73   |    49    |                      I                       |                                    |
| 01001010 |   74   |    4A    |                      J                       |                                    |
| 01001011 |   75   |    4B    |                      K                       |                                    |
| 01001100 |   76   |    4C    |                      L                       |                                    |
| 01001101 |   77   |    4D    |                      M                       |                                    |
| 01001110 |   78   |    4E    |                      N                       |                                    |
| 01001111 |   79   |    4F    |                      O                       |                                    |
| 01010000 |   80   |    50    |                      P                       |                                    |
| 01010001 |   81   |    51    |                      Q                       |                                    |
| 01010010 |   82   |    52    |                      R                       |                                    |
| 01010011 |   83   |    53    |                      S                       |                                    |
| 01010100 |   84   |    54    |                      T                       |                                    |
| 01010101 |   85   |    55    |                      U                       |                                    |
| 01010110 |   86   |    56    |                      V                       |                                    |
| 01010111 |   87   |    57    |                      W                       |                                    |
| 01011000 |   88   |    58    |                      X                       |                                    |
| 01011001 |   89   |    59    |                      Y                       |                                    |
| 01011010 |   90   |    5A    |                      Z                       |                                    |
| 01011011 |   91   |    5B    |                      [                       |                                    |
| 01011100 |   92   |    5C    |                      \                       |                                    |
| 01011101 |   93   |    5D    |                      ]                       |                                    |
| 01011110 |   94   |    5E    |                      ^                       |                                    |
| 01011111 |   95   |    5F    |                      _                       |                                    |
| 01100000 |   96   |    60    |                      `                       |                                    |
| 01100001 |   97   |    61    |                      a                       |                                    |

| 01100010 | 98   | 62   | b            |      |
| -------- | ---- | ---- | ------------ | ---- |
| 01100011 | 99   | 63   | c            |      |
| 01100100 | 100  | 64   | d            |      |
| 01100101 | 101  | 65   | e            |      |
| 01100110 | 102  | 66   | f            |      |
| 01100111 | 103  | 67   | g            |      |
| 01101000 | 104  | 68   | h            |      |
| 01101001 | 105  | 69   | i            |      |
| 01101010 | 106  | 6A   | j            |      |
| 01101011 | 107  | 6B   | k            |      |
| 01101100 | 108  | 6C   | l            |      |
| 01101101 | 109  | 6D   | m            |      |
| 01101110 | 110  | 6E   | n            |      |
| 01101111 | 111  | 6F   | o            |      |
| 01110000 | 112  | 70   | p            |      |
| 01110001 | 113  | 71   | q            |      |
| 01110010 | 114  | 72   | r            |      |
| 01110011 | 115  | 73   | s            |      |
| 01110100 | 116  | 74   | t            |      |
| 01110101 | 117  | 75   | u            |      |
| 01110110 | 118  | 76   | v            |      |
| 01110111 | 119  | 77   | w            |      |
| 01111000 | 120  | 78   | x            |      |
| 01111001 | 121  | 79   | y            |      |
| 01111010 | 122  | 7A   | z            |      |
| 01111011 | 123  | 7B   | {            |      |
| 01111100 | 124  | 7C   | \|           |      |
| 01111101 | 125  | 7D   | }            |      |
| 01111110 | 126  | 7E   | ~            |      |
| 01111111 | 127  | 7F   | DEL (Delete) | 删除 |

## 库函数：

| 头文件     | 函数原型                                                     | 功能                                                         |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| <math.h>   | float fabs(float x)                                          | 求浮点数x的绝对值                                            |
|            | int abs(int x)                                               | 求整数x的绝对值                                              |
|            | float acos(float x)                                          | 求x（弧度表示）的反余弦值                                    |
|            | float asin(float x)                                          | 求x（弧度表示）的反正弦值                                    |
|            | float atan(float x)                                          | 求x（弧度表示）的反正切值                                    |
|            | float atan2(float y, float x)                                | 求y/x（弧度表示）的反正切值                                  |
|            | float ceil(float x)                                          | 求不小于x的最小整数                                          |
|            | float cos(float x)                                           | 求x（弧度表示）的余弦值                                      |
|            | float cosh(float x)                                          | 求x的双曲余弦值                                              |
|            | float exp(float x)                                           | 求e的x次幂                                                   |
|            | float floor(float x)                                         | 求不大于x的最大整数                                          |
|            | float fmod(float x, float y)                                 | 计算x/y的余数                                                |
|            | float frexp(float x, int *exp)                               | 把浮点数x分解成尾数和指数                                    |
|            | float ldexp(float x, int exp)                                | 返回x*2^exp的值                                              |
|            | float modf(float num, float *i)                              | 将浮点数num分解成整数部分和小数部分                          |
|            | float hypot(float x, float y)                                | 对于给定的直角三角形的两个直角边，求其斜边的长度             |
|            | float log(float x)                                           | 计算x的自然对数                                              |
|            | float log10(float x)                                         | 计算x的常用对数                                              |
|            | float pow(float x, float y)                                  | 计算x的y次幂                                                 |
|            | float pow10(float x)                                         | 计算10的x次幂                                                |
|            | float sin(float x)                                           | 计算x（弧度表示）的正弦值                                    |
|            | float sinh(float x)                                          | 计算x（弧度表示）的双曲正弦值                                |
|            | float sqrt(float x)                                          | 计算x的平方根                                                |
|            | float tan(float x);                                          | 计算x（弧度表示）的正切值                                    |
|            | float tanh(float x)                                          | 求x的双曲正切值                                              |
| <stdio.h>  | int printf(char *format...)                                  | 产生格式化输出的函数                                         |
|            | int getchar(void)                                            | 从键盘上读取一个键，并返回该键的键值                         |
|            | int putchar(char c)                                          | 在屏幕上显示字符c                                            |
|            | FILE *fopen(char *filename, char *type)                      | 打开一个文件                                                 |
|            | FILE *freopen(char *filename, char *type,FILE *fp)           | 打开一个文件，并将该文件关联到fp指定的流                     |
|            | int fflush(FILE *stream)                                     | 清除一个流                                                   |
|            | int fclose(FILE *stream)                                     | 关闭一个文件                                                 |
|            | int remove(char *filename)                                   | 删除一个文件                                                 |
|            | int rename(char *oldname, char *newname)                     | 重命名文件                                                   |
|            | FILE *tmpfile(void)                                          | 以二进制方式打开暂存文件                                     |
|            | char *tmpnam(char *sptr)                                     | 创建一个唯一的文件名                                         |
|            | int setvbuf(FILE *stream, char *buf, int type, unsigned size) | 把缓冲区与流相关                                             |
|            | int fprintf(FILE *stream, char *format[, argument,...])      | 传送格式化输出到一个流中                                     |
|            | int scanf(char *format[,argument,...])                       | 执行格式化输入                                               |
|            | int fscanf(FILE *stream, char *format[,argument...])         | 从一个流中执行格式化输入                                     |
|            | int fgetc(FILE *stream)                                      | 从流中读取字符                                               |
|            | char *fgets(char *string, int n, FILE *stream)               | 从流中读取一字符串                                           |
|            | int fputc(int ch, FILE *stream)                              | 送一个字符到一个流中                                         |
|            | int fputs(char *string, FILE *stream)                        | 送一个字符到一个流中                                         |
|            | int getc(FILE *stream)                                       | 从流中取字符                                                 |
|            | int getchar(void)                                            | 从 stdin 流中读字符                                          |
|            | char *gets(char *string)                                     | 从流中取一字符串                                             |
|            | int putchar(int ch)                                          | 在 stdout 上输出字符                                         |
|            | int puts(char *string)                                       | 送一字符串到流中                                             |
|            | int ungetc(char c, FILE *stream)                             | 把一个字符退回到输入流中                                     |
|            | int fread(void *ptr, int size, int nitems, FILE *stream)     | 从一个流中读数据                                             |
|            | int fwrite(void *ptr, int size, int nitems, FILE *stream)    | 写内容到流中 int fseek                                       |
|            | (FILE *stream, long offset, int fromwhere)                   | 重定位流上的文件指针                                         |
|            | long ftell(FILE *stream)                                     | 返回当前文件指针                                             |
|            | int rewind(FILE *stream)                                     | 将文件指针重新指向一个流的开头                               |
|            | int fgetpos(FILE *stream)                                    | 取得当前文件的句柄                                           |
|            | int fsetpos(FILE *stream, const fpos_t *pos)                 | 定位流上的文件指针                                           |
|            | void clearerr(FILE *stream)                                  | 复位错误标志                                                 |
|            | int feof(FILE *stream)                                       | 检测流上的文件结束符                                         |
|            | int ferror(FILE *stream)                                     | 检测流上的错误                                               |
|            | void perror(char *string)                                    | 系统错误信息                                                 |
| <stdlib.h> | char *itoa(int i)                                            | 把整数i转换成字符串                                          |
|            | void exit(int retval)                                        | 结束程序                                                     |
|            | double atof(const char *s)                                   | 将字符串s转换为double类型                                    |
|            | int atoi(const char *s)                                      | 将字符串s转换为int类型                                       |
|            | long atol(const char *s)                                     | 将字符串s转换为long类型                                      |
|            | double strtod (const char*s,char **endp)                     | 将字符串s前缀转换为double型                                  |
|            | long strtol(const char*s,char **endp,int base)               | 将字符串s前缀转换为long型                                    |
|            | unsinged long strtol(const char*s,char **endp,int base)      | 将字符串s前缀转换为 unsinged long型                          |
|            | int rand(void)                                               | 产生一个0~RAND_MAX之间的伪随机数                             |
|            | void srand(unsigned int seed)                                | 初始化随机数发生器                                           |
|            | void *calloc(size_t nelem, size_t elsize)                    | 分配主存储器                                                 |
|            | void *malloc(unsigned size)                                  | 内存分配函数                                                 |
|            | void *realloc(void *ptr, unsigned newsize)                   | 重新分配主存                                                 |
|            | void free(void *ptr)                                         | 释放已分配的块                                               |
|            | void abort(void)                                             | 异常终止一个进程                                             |
|            | void exit(int status)                                        | 终止应用程序                                                 |
|            | int atexit(atexit_t func)                                    | 注册终止函数                                                 |
|            | char *getenv(char *envvar)                                   | 从环境中取字符串                                             |
|            | void *bsearch(const void *key, const void *base, size_t *nelem, size_t width, int(*fcmp)(const void *, const *)) | 二分法搜索函数                                               |
|            | void qsort(void *base, int nelem, int width, int (*fcmp)())  | 使用快速排序例程进行排序                                     |
|            | int abs(int i)                                               | 求整数的绝对值                                               |
|            | long labs(long n)                                            | 取长整型绝对值                                               |
|            | div_t div(int number, int denom)                             | 将两个整数相除 , 返回商和余数                                |
|            | ldiv_t ldiv(long lnumer, long ldenom)                        | 两个长整型数相除 , 返回商和余数                              |
| <string.h> | int bcmp(const void *s1, const void *s2, int n)              | 比较字符串s1和s2的前n个字节是否相等                          |
|            | void bcopy(const void *src, void *dest, int n)               | 将字符串src的前n个字节复制到dest中                           |
|            | void bzero(void *s, int n)                                   | 置字节字符串s的前n个字节为零                                 |
|            | void *memccpy(void *dest, void *src, unsigned char ch, unsigned int count) | 由src所指内存区域复制不多于count个字节到dest所指内存区域，如果遇到字符ch则停止复制 |
|            | void *memcpy(void *dest, void *src, unsigned int count)      | 由src所指内存区域复制count个字节到dest所指内存区域           |
|            | void *memchr(void *buf, char ch, unsigned count)             | 从buf所指内存区域的前count个字节查找字符ch                   |
|            | int memcmp(void *buf1, void *buf2, unsigned int count)       | 比较内存区域buf1和buf2的前count个字节                        |
|            | int memicmp(void *buf1, void *buf2, unsigned int count)      | 比较内存区域buf1和buf2的前count个字节但不区分字母的大小写    |
|            | void *memmove(void *dest, const void *src, unsigned int count) | 由src所指内存区域复制count个字节到dest所指内存区域           |
|            | void *memset(void *buffer, int c, int count)                 | 把buffer所指内存区域的前count个字节设置成字符c               |
|            | void setmem(void *buf, unsigned int count, char ch)          | 把buf所指内存区域前count个字节设置成字符ch                   |
|            | void movmem(void *src, void *dest, unsigned int count)       | 由src所指内存区域复制count个字节到dest所指内存区域           |
|            | char *stpcpy(char *dest,char *src)                           | 把src所指由NULL结束的字符串复制到dest所指的数组中            |
|            | char *strcpy(char *dest,char *src)                           | 把src所指由NULL结束的字符串复制到dest所指的数组中            |
|            | char *strcat(char *dest,char *src)                           | 把src所指字符串添加到dest结尾处(覆盖dest结尾处的’\0’)并添加’\0’ |
|            | char *strchr(char *s,char c)                                 | 查找字符串s中首次出现字符c的位置                             |
|            | int strcmp(char *s1,char * s2)                               | 比较字符串s1和s2                                             |
|            | int strcmp(char *s1,char * s2)                               | 比较字符串s1和s2                                             |
|            | int stricmp(char *s1,char * s2)                              | 比较字符串s1和s2，但不区分字母的大小写                       |
|            | int strcspn(char *s1,char *s2)                               | 在字符串s1中搜寻s2中所出现的字符                             |
|            | char *strdup(char *s)                                        | 复制字符串s                                                  |
|            | int strlen(char *s)                                          | 计算字符串s的长度                                            |
|            | char *strlwr(char *s)                                        | 将字符串s转换为小写形式                                      |
|            | char *strupr(char *s)                                        | 将字符串s转换为大写形式                                      |
|            | char *strncat(char *dest,char *src,int n)                    | 把src所指字符串的前n个字符添加到dest结尾处(覆盖dest结尾处的’\0’)并添加’\0’ |
|            | int strcmp(char *s1,char * s2，int n)                        | 比较字符串s1和s2的前n个字符                                  |
|            | int strnicmp(char *s1,char * s2，int n)                      | 比较字符串s1和s2的前n个字符但不区分大小写                    |
|            | char *strncpy(char *dest, char *src, int n)                  | 把src所指由NULL结束的字符串的前n个字节复制到dest所指的数组中 |
|            | char *strpbrk(char *s1, char *s2)                            | 在字符串s1中寻找字符串s2中任何一个字符相匹配的第一个字符的位置，空字符NULL不包括在内 |
|            | char *strrev(char *s)                                        | 把字符串s的所有字符的顺序颠倒过来（不包括空字符NULL）        |
|            | char *strset(char *s, char c)                                | 把字符串s中的所有字符都设置成字符c                           |
|            | char *strstr(char *haystack, char *needle)                   | 从字符串haystack中寻找needle第一次出现的位置（不比较结束符NULL) |
|            | char *strtok(char *s, char *delim)                           | 分解字符串为一组标记串。s为要分解的字符串，delim为分隔符字符串 |
|            | int strnicmp(char *s1,char * s2，int n)                      | 比较字符串s1和s2的前n个字符但不区分大小写                    |
| <time.h>   | clock_t clock(void)                                          | 确定处理器时间函数                                           |
|            | time_t time(time_t *tp)                                      | 返回当前日历时间                                             |
|            | double difftime(time_t time2, time_t time1)                  | 计算两个时刻之间的时间差                                     |
|            | time_t mktime(struct tm *tp)                                 | 将分段时间值转换为日历时间值                                 |
|            | char *asctime(const struct tm *tblock)                       | 转换日期和时间为ASCII码                                      |
|            | char *ctime(const time_t *time)                              | 把日期和时间转换为字符串                                     |
|            | struct tm *gmtime(const time_t *timer)                       | 把日期和时间转换为格林尼治标准时间                           |
|            | struct tm *localtime(const time_t *timer)                    | 把日期和时间转变为结构                                       |
|            | size_t strftime(char *s,size_t smax,const char *fmt, const struct tm *tp) | 根据 fmt 的格式 要求将 *tp中的日期与时间转换为指定格式       |
| <ctype.h>  | int iscntrl(int c)                                           | 判断字符c是否为控制字符。                                    |
|            | int isalnum(int c)                                           | 判断字符c是否为字母或数字                                    |
|            | int isalpha(int c)                                           | 判断字符c是否为英文字母                                      |
|            | int isascii(int c)                                           | 判断字符c是否为ascii码                                       |
|            | int isblank(int c)                                           | 判断字符c是否为TAB或空格                                     |
|            | int isdigit(int c)                                           | 判断字符c是否为数字                                          |
|            | int isgraph(int c)                                           | 判断字符c是否为除空格外的可打印字符                          |
|            | int islower(int c)                                           | 判断字符c是否为小写英文字母                                  |
|            | int isprint(int c)                                           | 判断字符c是否为可打印字符（含空格）                          |
|            | int ispunct(int c)                                           | 判断字符c是否为标点符号                                      |
|            | int isspace(int c)                                           | 判断字符c是否为空白符                                        |
|            | int isupper(int c)                                           | 判断字符c是否为大写英文字母                                  |
|            | int isxdigit(int c)                                          | 判断字符c是否为十六进制数字                                  |
|            | int toascii(int c)                                           | 将字符c转换为ascii码                                         |
|            | int tolower(int c)                                           | 将字符c转换为小写英文字母                                    |
|            | int toupper(int c);                                          | 将字符c转换为大写英文字母                                    |

